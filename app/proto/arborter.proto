syntax = "proto3";

package xyz.aspens.arborter.v1;

option optimize_for = SPEED;

service ArborterService {
  rpc SendOrder(SendOrderRequest) returns (SendOrderResponse) {}
  rpc CancelOrder(CancelOrderRequest) returns (CancelOrderResponse) {}
  rpc GetRecentTrades(Empty) returns (stream Trade) {}
  rpc Orderbook(OrderbookRequest) returns (stream OrderbookEntry) {}
}

message Empty {}

message CancelOrderRequest {
  OrderToCancel order = 1;
  bytes signature_hash = 2;
}

message CancelOrderResponse {
  // Whether the order was found and canceled
  bool order_canceled = 1;
}

message OrderbookRequest {
  // Used to keep the client alive
  bool continue_stream = 1;
}

message SendOrderRequest {
  // The order to send
  Order order = 1;
  // Valid EIP-712 signature hash of this order
  bytes signature_hash = 2;
}

message Order {
  // 'BID' or 'ASK'
  Side side = 1;
  // Order size
  uint64 quantity = 2;
  // Optional. including is a LIMIT order. excluding is a MARKET order.
  optional uint64 price = 3;
  // Identity the market: concat(base_chain_id "::" token_address "::" quote_chain_id "::" token_address)
  string market_id = 4;
  // User's pubkey (address)on the Base chain
  string base_account_address = 5;
  // User's pubkey (address)on the Quote chain
  string quote_account_address = 6;
  // 'DIRECT' (default) or 'DISCRETIONARY'
  ExecutionType execution_type = 7;
  // When execution_type == 'discretionary', include order_ids to match with.
  repeated uint64 matching_order_ids = 8;
}

enum Side {
  SIDE_UNSPECIFIED = 0;
  SIDE_BID = 1;
  SIDE_ASK = 2;
}

enum ExecutionType {
  // Default - direct
  EXECUTION_TYPE_UNSPECIFIED = 0;
  // For dealroom use.
  EXECUTION_TYPE_DISCRETIONARY = 1;
}

enum OrderStatus {
  ORDER_STATUS_UNSPECIFIED = 0;
  // When new order is added to the book
  ORDER_STATUS_ADDED = 1;
  // When an existing order is updated
  ORDER_STATUS_UPDATED = 2;
  // When an existing order is filled completely or canceled
  ORDER_STATUS_REMOVED = 3;
}

message Trade {
  // When the engine registers this executed trade
  uint64 timestamp = 1;
  // The setttled price net of fees
  uint64 price = 2;
  // How much or many of the quote token
  uint64 qty = 3;
  // Maker's internal trader id. Safely ignore.
  string maker = 4;
  // Taker's internal trader id. Safely ignore.
  string taker = 5;
  // The maker's base chain wallet address
  string maker_base_address = 6;
  // The maker's quote chain wallet address
  string maker_quote_address = 7;
  // Buyer's internal trader id. Safely ignore.
  string buyer = 8;
  // Seller's internal trader id. Safely ignore.
  string seller = 9;
  // The order_id that created this trade.
  uint64 order_hit = 10;
}

/* rpc: SendOrder */
message SendOrderResponse {
  // Whether the order has unmatched volume and has been added to the book.
  bool order_in_book = 1;
  // If the order lands in the book, what remains unfilled from the order.
  optional Order order = 2;
  // Which other orders, if any, this order was matched with.
  repeated Trade trades = 3;
}

/* rpc: CancelOrder */
message OrderToCancel {
  // Identity the market: concat(base_chain_id "::" token_address "::" quote_chain_id "::" token_address)
  string market_id = 1;
  // 'BID' or 'ASK'
  Side side = 2;
  // the token address
  string token_address = 3;
  // Internal order Id.
  uint64 order_id = 4;
}


/* rpc: Orderbook */
message OrderbookEntry {
  // when the order first landed in The Orderbook
  uint64 timestamp = 1;
  // internal id of the order
  uint64 order_id = 2;
  // price of the order - in non-decimal form
  uint64 price = 3;
  // quantity of the order - in non-decimal form
  uint64 quantity = 4;
  // 'BID = 1' or 'ASK = 2'
  Side side = 5;
  // The maker's base chain wallet address
  string maker_base_address = 6;
  // The maker's quote chain wallet address
  string maker_quote_address = 7;
  // 'ADDED = 1', 'UPDATED = 2', 'REMOVED = 3'
  OrderStatus status = 8;
}
